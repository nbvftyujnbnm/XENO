<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>XENO Game</title>
    <link rel="stylesheet" href="style.css">
    <style>
        /* This file's specific styles */
        :root {
            --board-bg: #1a2a1a;
            --player-area-bg: #2a4a2a;
            --card-bg: #f0ead6;
            --card-back-bg: #5a3a2a;
            --card-border: #333;
            --text-color: #f0f0f0;
            --accent-color: #ffc107;
            --turn-indicator-color: #ffc107;
            --danger-color: #dc3545;
            --safe-color: #28a745;
            --info-color: #0dcaf0;
        }

        body.game-active {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: var(--board-bg);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .game-board {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 20px);
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }

        .player-area {
            background-color: var(--player-area-bg);
            border-radius: 10px;
            padding: 10px;
            margin: 5px 0;
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 3px solid transparent;
            transition: border-color 0.3s ease;
        }
        
        .player-area.is-turn {
            border-color: var(--turn-indicator-color);
            box-shadow: 0 0 10px var(--turn-indicator-color);
        }
        
        .player-area.is-protected {
            border-color: var(--safe-color);
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-name {
            font-weight: bold;
            font-size: 1.2em;
        }
        
        .status-icon {
            font-size: 1.5em;
            margin-left: 10px;
        }

        .cards-container {
            display: flex;
            gap: 10px;
            flex: 1;
            min-height: 130px;
        }

        .hand-area {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
        }

        .discard-pile {
            flex-basis: 150px;
            flex-shrink: 0;
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
            padding: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-content: flex-start;
            overflow-y: auto;
        }

        .card {
            width: 80px;
            height: 120px;
            background-color: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: #000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            box-sizing: border-box;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.3);
            position: relative;
            font-size: 0.9em;
            text-align: center;
            transition: all 0.2s ease-out;
        }
        
        .discard-pile .card, .info-cards .card {
            width: 40px;
            height: 60px;
            font-size: 0.6em;
            pointer-events: none;
        }
        
        .discard-pile .card .card-number, .info-cards .card .card-number { font-size: 1.2em; }
        .discard-pile .card .card-name, .info-cards .card .card-name { font-size: 0.8em; font-weight: normal; }
        .discard-pile .card .card-number-bottom, .info-cards .card .card-number-bottom { display: none; }


        .card.back {
            background-color: var(--card-back-bg);
            background-image: repeating-linear-gradient(45deg, #6b4a3a, #6b4a3a 10px, #5a3a2a 10px, #5a3a2a 20px);
            color: transparent;
        }
        
        .card.playable:hover {
            transform: translateY(-10px) scale(1.05);
            cursor: pointer;
            box-shadow: 0 0 15px var(--accent-color);
        }

        .card-number {
            font-size: 1.5em;
            font-weight: bold;
            align-self: flex-start;
        }
        .card-number-bottom {
            font-size: 1.5em;
            font-weight: bold;
            align-self: flex-end;
            transform: rotate(180deg);
        }
        
        .card-name {
            font-size: 1.1em;
            font-weight: bold;
        }

        .center-area {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 10px 0;
            gap: 10px;
        }

        .deck-pile-container {
            text-align: center;
        }

        .message-log {
            flex-grow: 1;
            background-color: rgba(0,0,0,0.5);
            border-radius: 5px;
            padding: 10px;
            height: 100px;
            overflow-y: auto;
            border: 1px solid var(--card-border);
            display: flex;
            flex-direction: column-reverse;
        }
        
        .message-log p {
            margin: 5px 0 0 0;
            font-size: 0.9em;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: var(--player-area-bg);
            padding: 20px;
            border: 1px solid #888;
            width: 90%;
            max-width: 500px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            color: var(--text-color);
        }
        
        .modal-content h2 {
            margin-top: 0;
            color: var(--accent-color);
        }
        
        .modal-choices {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .modal-choices.vertical {
            flex-direction: column;
            align-items: center;
        }

        .modal-choices button {
            background-color: var(--accent-color);
            color: #000;
            border: none;
            padding: 10px 15px;
            text-align: center;
            font-size: 16px;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        .modal-choices button:hover {
            background-color: #ffda73;
        }
        
        .info-button {
            background-color: var(--info-color) !important;
            margin-top: 10px;
        }

        #new-game-button {
             background-color: var(--safe-color);
             color: white;
             padding: 12px 25px;
             font-size: 18px;
             margin-top: 15px;
        }
        
        .info-modal-content, .rule-modal-content {
            text-align: left;
            max-height: 80vh;
            overflow-y: auto;
        }
        .info-section, .rule-section {
            margin-bottom: 15px;
        }
        .info-section h3, .rule-section h3 {
            border-bottom: 1px solid var(--accent-color);
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        .info-cards {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .game-controls {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            z-index: 500;
        }
        .game-controls .button {
            padding: 6px 10px;
            font-size: 0.75rem;
            font-weight: normal;
            background-color: rgba(0, 0, 0, 0.4);
            color: #f0f0f0;
            border: 1px solid rgba(240, 240, 240, 0.5);
            min-width: auto;
            text-align: center;
        }
        .game-controls .button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: none;
        }
        
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }
        .close-button:hover,
        .close-button:focus {
            color: white;
        }
        
        .rule-list {
            list-style: none;
            padding-left: 0;
            font-size: 0.9em;
        }
        .rule-list li {
            margin-bottom: 12px;
            padding-left: 1.5em;
            text-indent: -1.5em;
            line-height: 1.5;
        }
        .rule-list strong {
            color: var(--accent-color);
            display: inline-block;
            width: 70px;
            font-size: 1.1em;
        }

    </style>
</head>
<body class="game-active">

<div class="game-controls">
    <button id="rule-button" class="button">ãƒ«ãƒ¼ãƒ«</button>
    <a href="index.html" class="button">çµ‚äº†</a>
</div>

<div class="game-board">
    <div id="cpu-area" class="player-area">
        <div class="player-info">
            <div>
                <span id="cpu-name" class="player-name">CPU</span>
                <span id="cpu-status" class="status-icon"></span>
            </div>
        </div>
        <div class="cards-container">
            <div id="cpu-hand" class="hand-area"></div>
            <div id="cpu-discard" class="discard-pile"></div>
        </div>
    </div>

    <div class="center-area">
        <div class="deck-pile-container">
            <div id="deck" class="card back"></div>
            <div>å±±æœ­: <span id="deck-count">0</span></div>
        </div>
        <div class="message-log" id="message-log"></div>
    </div>

    <div id="player-area" class="player-area">
        <div class="cards-container">
            <div id="player-hand" class="hand-area"></div>
            <div id="player-discard" class="discard-pile"></div>
        </div>
        <div class="player-info" style="margin-top: 10px;">
             <div>
                <span id="player-name" class="player-name">ã‚ãªãŸ</span>
                <span id="player-status" class="status-icon"></span>
            </div>
        </div>
    </div>
</div>

<div id="game-over-modal" class="modal">
    <div class="modal-content">
        <h2 id="game-over-message"></h2>
        <p id="game-over-details"></p>
        <button id="new-game-button">æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã‚‹</button>
    </div>
</div>

<div id="action-modal" class="modal">
    <div class="modal-content">
        <h2 id="action-modal-title"></h2>
        <p id="action-modal-description"></p>
        <div class="modal-choices" id="action-modal-choices"></div>
    </div>
</div>

<div id="info-modal" class="modal">
    <div class="modal-content info-modal-content">
        <h2 id="info-modal-title">ç›¤é¢æƒ…å ±</h2>
        <div id="info-modal-body"></div>
        <div class="modal-choices">
            <button id="info-modal-back-button">æˆ»ã‚‹</button>
        </div>
    </div>
</div>

<div id="rule-modal" class="modal">
    <div class="modal-content rule-modal-content">
        <span class="close-button" id="rule-modal-close">&times;</span>
        <h2>ã‚²ãƒ¼ãƒ ã®ãƒ«ãƒ¼ãƒ«</h2>
        <div class="rule-section">
            <h3>ç›®çš„</h3>
            <p>ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è„±è½ã•ã›ã‚‹ã‹ã€å±±æœ­ãŒãªããªã£ãŸæ™‚ç‚¹ã§ã®ã‚«ãƒ¼ãƒ‰ã®æ•°å­—æ¯”ã¹ã§å‹åˆ©ã™ã‚‹ã“ã¨ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚</p>
        </div>
        <div class="rule-section">
            <h3>ã‚²ãƒ¼ãƒ ã®æµã‚Œ</h3>
            <p>1. å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ‰‹æœ­ã‚’1æšæŒã¡ã¾ã™ã€‚</p>
            <p>2. è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã«ãªã£ãŸã‚‰ã€å±±æœ­ã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’1æšå¼•ãã¾ã™ã€‚</p>
            <p>3. æ‰‹æœ­ãŒ2æšã«ãªã£ãŸã‚‰ã€ã©ã¡ã‚‰ã‹1æšã‚’é¸ã‚“ã§å ´ã«å‡ºã—ã€ãã®ã‚«ãƒ¼ãƒ‰ã®åŠ¹æœã‚’ç™ºå‹•ã—ã¾ã™ã€‚</p>
            <p>4. ã“ã‚Œã‚’ç¹°ã‚Šè¿”ã—ã€å‹æ•—ãŒæ±ºã¾ã‚‹ã¾ã§ç¶šã‘ã¾ã™ã€‚</p>
        </div>
         <div class="rule-section">
            <h3>ã‚«ãƒ¼ãƒ‰ã®åŠ¹æœ</h3>
            <ul class="rule-list">
                <li><strong>è‹±é›„ (10):</strong> æ¨ã¦ã•ã›ã‚‰ã‚ŒãŸæ™‚ï¼ˆçš‡å¸ã‚’é™¤ãï¼‰ã€ä»–ã®æ‰‹æœ­ã‚’å…¨ã¦æ¨ã¦å±±æœ­ã‹ã‚‰1æšå¼•ãï¼ˆè»¢ç”Ÿï¼‰ã€‚è‡ªåˆ†ã§ã¯ãƒ—ãƒ¬ã‚¤ã§ããªã„ã€‚</li>
                <li><strong>çš‡å¸ (9):</strong> ç›¸æ‰‹ã¯å±±æœ­ã‚’1æšå¼•ãã€‚ãã®å¾Œã€ç›¸æ‰‹ã®2æšã®æ‰‹æœ­ã‚’å…¬é–‹ã•ã›ã€ã‚ãªãŸãŒ1æšé¸ã‚“ã§æ¨ã¦ã•ã›ã‚‹ã€‚è‹±é›„ã‚’æ¨ã¦ã•ã›ã‚‹ã¨è»¢ç”Ÿã§ããªã„ã€‚</li>
                <li><strong>ç²¾éœŠ (8):</strong> ç›¸æ‰‹ã¨æ‰‹æœ­ã‚’äº¤æ›ã™ã‚‹ã€‚</li>
                <li><strong>è³¢è€… (7):</strong> æ¬¡ã®è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã€å±±æœ­ã‹ã‚‰3æšå¼•ã1æšã‚’æ‰‹æœ­ã«åŠ ãˆã€æ®‹ã‚Šã‚’å±±æœ­ã«æˆ»ã™ã€‚</li>
                <li><strong>è²´æ— (6):</strong> 2æšç›®ã«å‡ºãŸæ™‚ã€ãŠäº’ã„ã®æ‰‹æœ­ã‚’æ¯”ã¹ã€æ•°å­—ãŒå°ã•ã„æ–¹ãŒè„±è½ã™ã‚‹ï¼ˆå¯¾æ±ºï¼‰ã€‚</li>
                <li><strong>æ­»ç¥ (5):</strong> ç›¸æ‰‹ã¯å±±æœ­ã‚’1æšå¼•ãã€‚ãã®å¾Œã€2æšã®æ‰‹æœ­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã§1æšãŒæ¨ã¦ã‚‰ã‚Œã‚‹ã€‚</li>
                <li><strong>ä¹™å¥³ (4):</strong> æ¬¡ã®è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã¾ã§ã€ç›¸æ‰‹ã®ã‚«ãƒ¼ãƒ‰åŠ¹æœã‚’å—ã‘ãªã„ã€‚</li>
                <li><strong>å å¸« (3):</strong> ç›¸æ‰‹ã®æ‰‹æœ­ã‚’è¦‹ã‚‹ã€‚</li>
                <li><strong>å…µå£« (2):</strong> è‹±é›„ä»¥å¤–ã®ã‚«ãƒ¼ãƒ‰ã‚’1æšå®£è¨€ã—ã€ç›¸æ‰‹ã®æ‰‹æœ­ãŒãã®ã‚«ãƒ¼ãƒ‰ãªã‚‰è„±è½ã•ã›ã‚‹ã€‚</li>
                <li><strong>å°‘å¹´ (1):</strong> 2æšç›®ã«å‡ºãŸæ™‚ã€é©å‘½ãŒèµ·ãã‚‹ï¼ˆè‹±é›„ã‚‚è»¢ç”Ÿã§ãã‚‹çš‡å¸ã®åŠ¹æœï¼‰ã€‚</li>
            </ul>
        </div>
    </div>
</div>

<script>
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

    const CONSTANTS = {
        PLAYER_ID: 'player', CPU_ID: 'cpu', REVEAL_DURATION: 5000, TURN_DELAY: 1000,
        CPU_THINK_TIME: 1500,
        EFFECT_SOURCE: { EMPEROR: 'emperor', REVOLUTION: 'revolution', EFFECT: 'effect' },
        CARD_NUMBERS: { BOY: 1, SOLDIER: 2, FORTUNE_TELLER: 3, MAIDEN: 4, REAPER: 5,
            NOBLE: 6, SAGE: 7, SPIRIT: 8, EMPEROR: 9, HERO: 10 },
    };

    const CARD_DATA = {
        [CONSTANTS.CARD_NUMBERS.BOY]: { name: 'å°‘å¹´', count: 2 },
        [CONSTANTS.CARD_NUMBERS.SOLDIER]: { name: 'å…µå£«', count: 2 },
        [CONSTANTS.CARD_NUMBERS.FORTUNE_TELLER]: { name: 'å å¸«', count: 2 },
        [CONSTANTS.CARD_NUMBERS.MAIDEN]: { name: 'ä¹™å¥³', count: 2 },
        [CONSTANTS.CARD_NUMBERS.REAPER]: { name: 'æ­»ç¥', count: 2 },
        [CONSTANTS.CARD_NUMBERS.NOBLE]: { name: 'è²´æ—', count: 2 },
        [CONSTANTS.CARD_NUMBERS.SAGE]: { name: 'è³¢è€…', count: 2 },
        [CONSTANTS.CARD_NUMBERS.SPIRIT]: { name: 'ç²¾éœŠ', count: 2 },
        [CONSTANTS.CARD_NUMBERS.EMPEROR]: { name: 'çš‡å¸', count: 1 },
        [CONSTANTS.CARD_NUMBERS.HERO]: { name: 'è‹±é›„', count: 1 },
    };

    class Game {
        constructor() {
            this.ui = this.getUIReferences();
            this.state = {};
            this.bindEventListeners();
            this.initGame();
        }

        getUIReferences() {
            return {
                deckCount: document.getElementById('deck-count'), log: document.getElementById('message-log'),
                player: { area: document.getElementById('player-area'), hand: document.getElementById('player-hand'), discard: document.getElementById('player-discard'), status: document.getElementById('player-status'), },
                cpu: { area: document.getElementById('cpu-area'), hand: document.getElementById('cpu-hand'), discard: document.getElementById('cpu-discard'), status: document.getElementById('cpu-status'), },
                modals: {
                    gameOver: document.getElementById('game-over-modal'), gameOverMessage: document.getElementById('game-over-message'),
                    gameOverDetails: document.getElementById('game-over-details'), newGameButton: document.getElementById('new-game-button'),
                    action: document.getElementById('action-modal'), actionTitle: document.getElementById('action-modal-title'),
                    actionDescription: document.getElementById('action-modal-description'), actionChoices: document.getElementById('action-modal-choices'),
                    info: document.getElementById('info-modal'), infoBody: document.getElementById('info-modal-body'),
                    infoBackButton: document.getElementById('info-modal-back-button'), rule: document.getElementById('rule-modal'),
                    ruleButton: document.getElementById('rule-button'), ruleCloseButton: document.getElementById('rule-modal-close'),
                }
            };
        }
        
        bindEventListeners() {
            this.ui.modals.newGameButton.addEventListener('click', () => this.initGame());
            this.ui.modals.infoBackButton.addEventListener('click', () => this.handleInfoBackClick());
            this.ui.modals.ruleButton.addEventListener('click', () => this.ui.modals.rule.style.display = 'flex');
            this.ui.modals.ruleCloseButton.addEventListener('click', () => this.ui.modals.rule.style.display = 'none');
        }

        initGame() {
            this.state = {
                deck: [],
                [CONSTANTS.PLAYER_ID]: { id: CONSTANTS.PLAYER_ID, name: 'ã‚ãªãŸ', hand: [], discard: [], isProtected: false, isOut: false, hasSageEffect: false },
                [CONSTANTS.CPU_ID]: { id: CONSTANTS.CPU_ID, name: 'CPU', hand: [], discard: [], isProtected: false, isOut: false, hasSageEffect: false },
                turn: CONSTANTS.PLAYER_ID, gameOver: false, isEffectActive: false,
            };
            
            for (const number in CARD_DATA) {
                for (let i = 0; i < CARD_DATA[number].count; i++) {
                    this.state.deck.push({ number: parseInt(number), name: CARD_DATA[number].name });
                }
            }
            this.shuffleDeck();
            this.drawCard(CONSTANTS.PLAYER_ID);
            this.drawCard(CONSTANTS.CPU_ID);
            this.logMessage('ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™ã€‚');
            this.ui.modals.gameOver.style.display = 'none';

            // ä¿®æ­£: requestAnimationFrameã§åˆå›æç”»ã‚’ãƒ©ãƒƒãƒ—
            requestAnimationFrame(() => {
                this.updateUI();
            });
            
            this.startTurn();
        }

        updateUI() {
            const updatePlayerArea = (playerId) => {
                const playerState = this.state[playerId];
                const playerUI = this.ui[playerId];
                playerUI.hand.innerHTML = '';
                playerState.hand.forEach((card, index) => playerUI.hand.appendChild(this.createCardElement(card, playerId, index)));
                playerUI.discard.innerHTML = '';
                playerState.discard.forEach(card => playerUI.discard.appendChild(this.createCardElement(card, 'discard')));
                playerUI.area.classList.toggle('is-turn', this.state.turn === playerId && !this.state.gameOver);
                playerUI.status.textContent = playerState.isProtected ? 'ğŸ›¡ï¸' : '';
            };
            updatePlayerArea(CONSTANTS.PLAYER_ID);
            updatePlayerArea(CONSTANTS.CPU_ID);
            this.ui.deckCount.textContent = this.state.deck.length;
        }
        
        createCardElement(card, owner, cardIndex = -1) {
            const el = document.createElement('div');
            el.classList.add('card');
            const isCpuCard = owner === CONSTANTS.CPU_ID;
            const isRevealed = card.isRevealed || (owner === CONSTANTS.PLAYER_ID) || this.state.gameOver;
            if (isCpuCard && !isRevealed) {
                el.classList.add('back');
            } else {
                el.innerHTML = `
                    <div class="card-number">${card.number}</div>
                    <div class="card-name">${card.name}</div>
                    <div class="card-number-bottom">${card.number}</div>`;
            }
            const isPlayable = owner === CONSTANTS.PLAYER_ID && this.state.turn === CONSTANTS.PLAYER_ID && this.state.player.hand.length === 2 && !this.state.isEffectActive;
            if (isPlayable) {
                el.classList.add('playable');
                el.addEventListener('click', () => this.playCard(CONSTANTS.PLAYER_ID, card, cardIndex));
            }
            return el;
        }

        logMessage(msg) {
            const p = document.createElement('p');
            p.textContent = msg;
            this.ui.log.prepend(p);
        }

        async startTurn() {
            if (this.state.gameOver) return;
            const currentPlayerId = this.state.turn;
            const currentPlayer = this.state[currentPlayerId];
            this.logMessage(`--- ${currentPlayer.name}ã®ã‚¿ãƒ¼ãƒ³ ---`);
            currentPlayer.isProtected = false;
            if (currentPlayer.hasSageEffect) {
                currentPlayer.hasSageEffect = false;
                this.logMessage(`${currentPlayer.name}ã¯ã€Œè³¢è€…ã€ã®åŠ¹æœã‚’ç™ºå‹•ï¼`);
                const drawnCards = [];
                const drawCount = Math.min(3, this.state.deck.length);
                if (drawCount > 0) {
                    for (let i = 0; i < drawCount; i++) drawnCards.push(this.state.deck.pop());
                    const chosenCard = await this.promptForChoice({
                        playerId: currentPlayerId, type: 'card', title: 'è³¢è€…ã®åŠ¹æœ',
                        description: 'æ‰‹æœ­ã«åŠ ãˆã‚‹ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã‚“ã§ãã ã•ã„ã€‚', options: drawnCards
                    });
                    currentPlayer.hand.push(chosenCard);
                    const returnedCards = drawnCards.filter(c => c !== chosenCard);
                    if (returnedCards.length > 0) {
                        this.state.deck.push(...returnedCards);
                        this.shuffleDeck();
                    }
                    this.logMessage(`${currentPlayer.name}ã¯ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã³ã€æ®‹ã‚Šã‚’å±±æœ­ã«æˆ»ã—ãŸã€‚`);
                } else {
                    this.logMessage('ã—ã‹ã—å±±æœ­ã«ã‚«ãƒ¼ãƒ‰ãŒãªã‹ã£ãŸã€‚');
                }
            } else {
                if (!this.drawCard(currentPlayerId)) {
                    this.endGame(this.checkWinCondition());
                    return;
                }
            }
            this.updateUI();
            if (currentPlayerId === CONSTANTS.CPU_ID) {
                await sleep(CONSTANTS.CPU_THINK_TIME);
                this.cpuTurn();
            }
        }
        
        async endTurn() {
            if (this.state.gameOver) return;
            const winner = this.checkWinCondition();
            if (winner) { this.endGame(winner); return; }
            this.state.turn = (this.state.turn === CONSTANTS.PLAYER_ID) ? CONSTANTS.CPU_ID : CONSTANTS.PLAYER_ID;
            await sleep(CONSTANTS.TURN_DELAY);
            this.startTurn();
        }

        async playCard(playerId, card, cardIndex) {
            if (card.number === CONSTANTS.CARD_NUMBERS.HERO) {
                this.logMessage('ã€Œè‹±é›„ã€ã¯æ‰‹æœ­ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ã§ãã¾ã›ã‚“ã€‚');
                return;
            }
            const player = this.state[playerId];
            if (this.state.turn !== playerId || player.hand.length < 2 || this.state.isEffectActive) return;
            this.state.isEffectActive = true;
            player.hand.splice(cardIndex, 1);
            player.discard.push(card);
            this.logMessage(`${player.name}ã¯ã€Œ${card.name}ã€ã‚’ãƒ—ãƒ¬ã‚¤ã€‚`);
            this.updateUI();
            const effectHandler = this.CARD_EFFECTS[card.number];
            if (effectHandler) await effectHandler.call(this, playerId);
            this.state.isEffectActive = false;
            this.endTurn();
        }

        CARD_EFFECTS = {
            async [CONSTANTS.CARD_NUMBERS.BOY](playerId) {
                const allDiscards = [...this.state.player.discard, ...this.state.cpu.discard];
                const boyCount = allDiscards.filter(c => c.number === CONSTANTS.CARD_NUMBERS.BOY).length;
                if (boyCount === 2) {
                    await this.executeRevolution(playerId);
                } else {
                    this.logMessage('ã€Œå°‘å¹´ã€ã®åŠ¹æœã€‚ä½•ã‚‚èµ·ã“ã‚‰ãªã„ã€‚');
                    await sleep(CONSTANTS.TURN_DELAY);
                }
            },
            async [CONSTANTS.CARD_NUMBERS.SOLDIER](playerId) {
                const guess = await this.promptForChoice({
                    playerId, type: 'button', title: 'æ¨æ¸¬',
                    description: 'ç›¸æ‰‹ã®æ‰‹æœ­ã®å½¹è·ã‚’æ¨æ¸¬ã—ã¦ãã ã•ã„ã€‚', options: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
                    showInfoButton: true,
                });
                if (guess === null) return;
                const opponent = this.state[this.getOpponentId(playerId)];
                this.logMessage(`${this.state[playerId].name}ã¯ã€Œ${CARD_DATA[guess].name}ã€ã¨æ¨æ¸¬ã€‚`);
                if (opponent.hand[0]?.number === guess) {
                    this.logMessage(`çš„ä¸­ï¼ ${opponent.name}ã¯è„±è½ã€‚`);
                    opponent.isOut = true;
                } else {
                    this.logMessage('ã—ã‹ã—ã€æ¨æ¸¬ã¯å¤–ã‚ŒãŸã€‚');
                }
                await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.FORTUNE_TELLER](playerId) {
                 const opponentId = this.getOpponentId(playerId);
                 if (this.state[opponentId].hand.length === 0) {
                    this.logMessage('ç›¸æ‰‹ã®æ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                 } else {
                    this.logMessage(`${this.state[playerId].name}ã¯${opponentId === CONSTANTS.PLAYER_ID ? 'è‡ªåˆ†' : 'ç›¸æ‰‹'}ã®æ‰‹æœ­ã‚’è¦‹ãŸã€‚`);
                    if (playerId === CONSTANTS.PLAYER_ID) {
                        await this.revealCard(opponentId, 0, CONSTANTS.REVEAL_DURATION);
                    }
                 }
                 await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.MAIDEN](playerId) {
                this.logMessage(`${this.state[playerId].name}ã¯æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã¾ã§å®ˆè­·çŠ¶æ…‹ã«ã€‚`);
                this.state[playerId].isProtected = true;
                this.updateUI();
                await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.REAPER](playerId) {
                const opponentId = this.getOpponentId(playerId);
                const opponent = this.state[opponentId];
                this.logMessage(`${opponent.name}ã¯å±±æœ­ã‹ã‚‰1æšå¼•ãã€‚`);
                this.drawCard(opponentId);
                this.updateUI();
                await sleep(CONSTANTS.TURN_DELAY);
                if (opponent.hand.length > 0) {
                    const discardIndex = Math.floor(Math.random() * opponent.hand.length);
                    this.logMessage(`2æšã®æ‰‹æœ­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«1æšãŒæ¨ã¦ã‚‰ã‚Œã‚‹...`);
                    await sleep(CONSTANTS.TURN_DELAY);
                    this.discardCard(opponentId, discardIndex);
                } else {
                    this.logMessage(`ã—ã‹ã—ç›¸æ‰‹ã®æ‰‹æœ­ãŒãªã‹ã£ãŸã€‚`);
                }
                if (this.state.gameOver) this.endGame(this.checkWinCondition());
                await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.NOBLE](playerId) {
                const opponentId = this.getOpponentId(playerId);
                const allDiscards = [...this.state.player.discard, ...this.state.cpu.discard];
                const nobleCount = allDiscards.filter(c => c.number === CONSTANTS.CARD_NUMBERS.NOBLE).length;
                if (nobleCount === 1) {
                     this.logMessage('1æšç›®ã®ã€Œè²´æ—ã€ã€‚ãŠäº’ã„ã®æ‰‹æœ­ã‚’è¦‹ã›åˆã†ã€‚');
                     await Promise.all([
                        this.revealCard(playerId, 0, CONSTANTS.REVEAL_DURATION),
                        this.revealCard(opponentId, 0, CONSTANTS.REVEAL_DURATION)
                     ]);
                } else {
                    this.logMessage('2æšç›®ã®ã€Œè²´æ—ã€ï¼å¯¾æ±ºã ï¼');
                    const player = this.state[playerId];
                    const opponent = this.state[opponentId];
                    if(player.hand.length === 0 || opponent.hand.length === 0) {
                        this.logMessage('ã—ã‹ã—ã€ã©ã¡ã‚‰ã‹ã®æ‰‹æœ­ãŒãªã‹ã£ãŸã€‚');
                        return;
                    }
                    await Promise.all([
                        this.revealCard(playerId, 0, CONSTANTS.REVEAL_DURATION),
                        this.revealCard(opponentId, 0, CONSTANTS.REVEAL_DURATION)
                    ]);
                    const pCard = player.hand[0].number;
                    const oCard = opponent.hand[0].number;
                    if (pCard > oCard) {
                        this.logMessage(`${player.name}ã®å‹åˆ©ï¼ ${opponent.name}ã¯è„±è½ã€‚`);
                        opponent.isOut = true;
                    } else if (oCard > pCard) {
                        this.logMessage(`${opponent.name}ã®å‹åˆ©ï¼ ${player.name}ã¯è„±è½ã€‚`);
                        player.isOut = true;
                    } else {
                        this.logMessage('å¼•ãåˆ†ã‘ã ã€‚');
                    }
                }
                await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.SAGE](playerId) {
                this.logMessage('ã€Œè³¢è€…ã€ã®åŠ¹æœã€‚æ¬¡ã®ã‚¿ãƒ¼ãƒ³ã€å±±æœ­ã‹ã‚‰3æšå¼•ãã€‚');
                this.state[playerId].hasSageEffect = true;
                await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.SPIRIT](playerId) {
                const opponentId = this.getOpponentId(playerId);
                const player = this.state[playerId];
                const opponent = this.state[opponentId];
                if(player.hand.length === 0 || opponent.hand.length === 0) {
                    this.logMessage('ã©ã¡ã‚‰ã‹ã®æ‰‹æœ­ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                    return;
                }
                this.logMessage(`${player.name}ã¯${opponent.name}ã¨æ‰‹æœ­ã‚’äº¤æ›ï¼`);
                [player.hand[0], opponent.hand[0]] = [opponent.hand[0], player.hand[0]];
                this.updateUI();
                await sleep(CONSTANTS.TURN_DELAY);
            },
            async [CONSTANTS.CARD_NUMBERS.EMPEROR](playerId) {
                const opponentId = this.getOpponentId(playerId);
                const opponent = this.state[opponentId];
                this.logMessage(`${opponent.name}ã¯å±±æœ­ã‹ã‚‰1æšå¼•ãã€‚`);
                this.drawCard(opponentId);
                this.updateUI();
                await sleep(CONSTANTS.TURN_DELAY);
                if(opponent.hand.length === 0) { 
                    this.logMessage('ã—ã‹ã—ç›¸æ‰‹ã®æ‰‹æœ­ãŒãªã‹ã£ãŸã€‚');
                    return; 
                }
                this.logMessage(`${this.state[playerId].name}ã¯${opponent.name}ã®æ‰‹æœ­ã‚’å…¬é–‹ã•ã›ã€1æšé¸ã‚“ã§æ¨ã¦ã•ã›ã‚‹ï¼`);
                await Promise.all(opponent.hand.map((_, index) => this.revealCard(opponentId, index, CONSTANTS.REVEAL_DURATION)));
                const cardToDiscard = await this.promptForChoice({
                    playerId, type: 'card', title: 'çš‡å¸ã®åŠ¹æœ',
                    description: 'æ¨ã¦ã•ã›ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã‚“ã§ãã ã•ã„ã€‚', options: opponent.hand
                });
                const cardIndexToDiscard = opponent.hand.findIndex(c => c === cardToDiscard);
                this.discardCard(opponentId, cardIndexToDiscard, CONSTANTS.EFFECT_SOURCE.EMPEROR);
                if(this.state.gameOver) this.endGame(this.checkWinCondition());
                await sleep(CONSTANTS.TURN_DELAY);
            },
        };

        async executeRevolution(playerId) {
            const opponentId = this.getOpponentId(playerId);
            const opponent = this.state[opponentId];
            if (opponent.isProtected) {
                this.logMessage(`ã—ã‹ã—ã€${opponent.name}ã¯ã€Œä¹™å¥³ã€ã®åŠ¹æœã§å®ˆã‚‰ã‚Œã¦ã„ã‚‹ï¼`);
                await sleep(CONSTANTS.TURN_DELAY);
                return;
            }
            this.logMessage(`${opponent.name}ã¯å±±æœ­ã‹ã‚‰1æšå¼•ãã€‚`);
            this.drawCard(opponentId);
            this.updateUI();
            await sleep(CONSTANTS.TURN_DELAY);
            if (opponent.hand.length === 0) {
                this.logMessage('ã—ã‹ã—ç›¸æ‰‹ã®æ‰‹æœ­ãŒãªã‹ã£ãŸã€‚');
                await sleep(CONSTANTS.TURN_DELAY);
                return;
            }
            this.logMessage(`${this.state[playerId].name}ã¯${opponent.name}ã®æ‰‹æœ­ã‚’å…¬é–‹ã•ã›ã€1æšé¸ã‚“ã§æ¨ã¦ã•ã›ã‚‹ï¼`);
            await Promise.all(opponent.hand.map((_, index) => this.revealCard(opponentId, index, CONSTANTS.REVEAL_DURATION)));
            const cardToDiscard = await this.promptForChoice({
                playerId, type: 'card', title: 'é©å‘½ã®åŠ¹æœ',
                description: 'æ¨ã¦ã•ã›ã‚‹ã‚«ãƒ¼ãƒ‰ã‚’1æšé¸ã‚“ã§ãã ã•ã„ã€‚', options: opponent.hand
            });
            const cardIndexToDiscard = opponent.hand.findIndex(c => c === cardToDiscard);
            this.discardCard(opponentId, cardIndexToDiscard, CONSTANTS.EFFECT_SOURCE.REVOLUTION);
            if (this.state.gameOver) this.endGame(this.checkWinCondition());
            await sleep(CONSTANTS.TURN_DELAY);
        }

        cpuTurn() {
            const hand = this.state.cpu.hand;
            if (hand.length < 2) { this.endTurn(); return; }
            const playableHand = hand.map((card, index) => ({ card, index })).filter(item => item.card.number !== CONSTANTS.CARD_NUMBERS.HERO);
            if (playableHand.length === 0) { this.endTurn(); return; }
            const sageInHand = playableHand.find(item => item.card.number === CONSTANTS.CARD_NUMBERS.SAGE);
            const choice = sageInHand || playableHand.sort((a,b) => a.card.number - b.card.number)[0];
            this.playCard(CONSTANTS.CPU_ID, choice.card, choice.index);
        }

        getOpponentId(playerId) {
            return playerId === CONSTANTS.PLAYER_ID ? CONSTANTS.CPU_ID : CONSTANTS.PLAYER_ID;
        }

        async promptForChoice({ playerId, type, title, description, options, showInfoButton = false }) {
            if (playerId === CONSTANTS.CPU_ID) return this.getCpuChoice(type, options);
            return new Promise(resolve => {
                this.ui.modals.actionTitle.textContent = title;
                this.ui.modals.actionDescription.textContent = description;
                const choicesContainer = this.ui.modals.actionChoices;
                choicesContainer.innerHTML = '';
                choicesContainer.className = 'modal-choices';
                const itemContainer = document.createElement('div');
                itemContainer.className = 'modal-choices';
                choicesContainer.appendChild(itemContainer);
                options.forEach(option => {
                    const el = type === 'card' ? this.createCardElement(option, CONSTANTS.PLAYER_ID) : document.createElement('button');
                    if (type === 'button') el.textContent = CARD_DATA[option].name;
                    el.style.cursor = 'pointer';
                    el.onclick = () => { this.ui.modals.action.style.display = 'none'; resolve(option); };
                    itemContainer.appendChild(el);
                });
                if (showInfoButton) {
                    const infoButton = document.createElement('button');
                    infoButton.textContent = 'ç›¤é¢ã®æƒ…å ±ã‚’ç¢ºèªã™ã‚‹'; infoButton.className = 'info-button';
                    infoButton.style.marginTop = '15px';
                    infoButton.onclick = () => { this.ui.modals.action.style.display = 'none'; this.showInfoModal(); };
                    choicesContainer.appendChild(infoButton);
                }
                this.ui.modals.action.style.display = 'flex';
            });
        }
        
        getCpuChoice(type, options) {
            if (type === 'card') {
                const hero = options.find(c => c.number === CONSTANTS.CARD_NUMBERS.HERO);
                const nonHero = options.find(c => c.number !== CONSTANTS.CARD_NUMBERS.HERO);
                if (hero && nonHero) return nonHero;
                return options.sort((a,b) => a.number - b.number)[0];
            }
            if (type === 'button') {
                const allDiscards = [...this.state.player.discard, ...this.state.cpu.discard];
                const discardCounts = allDiscards.reduce((acc, card) => { acc[card.number] = (acc[card.number] || 0) + 1; return acc; }, {});
                const validGuesses = options.filter(guess => (discardCounts[guess] || 0) < CARD_DATA[guess].count);
                const guessPool = validGuesses.length > 0 ? validGuesses : options;
                return guessPool[Math.floor(Math.random() * guessPool.length)];
            }
            return options[0];
        }

        showInfoModal() {
            let html = '';
            const createSection = (title, cards, owner) => {
                let sectionHtml = `<div class="info-section"><h3>${title}</h3><div class="info-cards">`;
                cards.forEach(card => { sectionHtml += this.createCardElement(card, owner).outerHTML; });
                return sectionHtml + '</div></div>';
            };
            html += createSection('ã‚ãªãŸã®æ‰‹æœ­', this.state.player.hand, CONSTANTS.PLAYER_ID);
            html += createSection('ã‚ãªãŸã®æ¨ã¦æœ­', this.state.player.discard, 'discard');
            html += createSection('CPUã®æ¨ã¦æœ­', this.state.cpu.discard, 'discard');
            this.ui.modals.infoBody.innerHTML = html;
            this.ui.modals.info.style.display = 'flex';
        }

        handleInfoBackClick() {
            this.ui.modals.info.style.display = 'none';
            this.ui.modals.action.style.display = 'flex';
        }

        shuffleDeck() {
            for (let i = this.state.deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.state.deck[i], this.state.deck[j]] = [this.state.deck[j], this.state.deck[i]];
            }
        }

        drawCard(playerId) {
            if (this.state.deck.length === 0) {
                this.logMessage('å±±æœ­ãŒãªããªã‚Šã¾ã—ãŸï¼');
                return false;
            }
            const card = this.state.deck.pop();
            this.state[playerId].hand.push(card);
            return true;
        }

        discardCard(playerId, handIndex, source = CONSTANTS.EFFECT_SOURCE.EFFECT) {
            const player = this.state[playerId];
            if (player.hand.length <= handIndex) return;
            const card = player.hand.splice(handIndex, 1)[0];
            player.discard.push(card);
            this.logMessage(`${player.name}ã¯ã€Œ${card.name}ã€ã‚’æ¨ã¦ã•ã›ã‚‰ã‚ŒãŸã€‚`);
            if (card.number === CONSTANTS.CARD_NUMBERS.HERO) {
                if (source === CONSTANTS.EFFECT_SOURCE.EMPEROR) {
                    this.logMessage('ã€Œè‹±é›„ã€ã¯ã€Œçš‡å¸ã€ã«ã‚ˆã£ã¦å‡¦åˆ‘ã•ã‚Œã€è»¢ç”Ÿã§ããªã„ï¼');
                    player.isOut = true;
                } else {
                    this.reincarnate(playerId);
                }
            }
            this.updateUI();
        }

        reincarnate(playerId) {
            const player = this.state[playerId];
            this.logMessage(`ã€Œè‹±é›„ã€ãŒæ¨ã¦ã‚‰ã‚ŒãŸï¼ ${player.name}ã¯è»¢ç”Ÿã—ã€å±±æœ­ã‹ã‚‰1æšå¼•ãã€‚`);
            while (player.hand.length > 0) {
                const cardInHand = player.hand.pop();
                player.discard.push(cardInHand);
                this.logMessage(`${player.name}ã¯æ‰‹æœ­ã®ã€Œ${cardInHand.name}ã€ã‚’æ¨ã¦ãŸã€‚`);
            }
            this.drawCard(playerId);
        }
        
        async revealCard(playerId, handIndex, duration) {
            const card = this.state[playerId].hand[handIndex];
            if (!card) return;
            card.isRevealed = true;
            this.updateUI();
            if (duration > 0) {
                await sleep(duration);
                const cardStillInHand = this.state[playerId].hand.includes(card);
                if (cardStillInHand && card.isRevealed) {
                    card.isRevealed = false;
                    this.updateUI();
                }
            }
        }
        
        checkWinCondition() {
            const player = this.state.player;
            const cpu = this.state.cpu;
            if (player.isOut) return cpu;
            if (cpu.isOut) return player;
            if (this.state.deck.length === 0 && player.hand.length < 2 && cpu.hand.length < 2) {
                this.logMessage('æœ€çµ‚æ±ºæˆ¦ï¼');
                const pCardNum = player.hand[0]?.number || 0;
                const cCardNum = cpu.hand[0]?.number || 0;
                if (pCardNum > cCardNum) return player;
                if (cCardNum > pCardNum) return cpu;
                return 'draw';
            }
            return null;
        }

        endGame(winner) {
            if (this.state.gameOver) return;
            this.state.gameOver = true;
            let message = '';
            const pCard = this.state.player.hand[0] || { name: 'ãªã—', number: 0 };
            const cCard = this.state.cpu.hand[0] || { name: 'ãªã—', number: 0 };
            const details = `æœ€çµ‚æ‰‹æœ­: ã‚ãªãŸ[${pCard.name}] vs CPU[${cCard.name}]`;
            message = (winner === 'draw') ? 'å¼•ãåˆ†ã‘ã§ã™ï¼' : `${winner.name}ã®å‹åˆ©ã§ã™ï¼`;
            this.logMessage(message);
            this.updateUI();
            this.showEndGameModal(message, details);
        }

        showEndGameModal(message, details) {
            this.ui.modals.gameOverMessage.textContent = message;
            this.ui.modals.gameOverDetails.textContent = details;
            this.ui.modals.gameOver.style.display = 'flex';
        }
    }
    
    window.addEventListener('load', () => {
        new Game();
    });
</script>

</body>
</html>


